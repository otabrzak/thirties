---
title: "Thirties"
author: "Ota Brz√°k"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.)

# Turn simulation function

```{r}
# This function simulates a player's turn
turn <- function() {
    
    # Number of dice still in game
    dice_left = 6
    
    # The number of current throw
    throw_num = 0
    
    # Final result of the turn
    final = c()
    
    while (dice_left>0){
        
        # Enumerate the throw
        throw_num = throw_num + 1
        
        # In a "bad" throw we do not want to keep any dice
        bad = TRUE
        throw = sample.int(6,size = dice_left, replace = TRUE)
        
        # Choose which dice to keep
        for (die in throw){
            
            if (die>=5){
                final = append(final, die)
                dice_left = dice_left - 1
                bad = FALSE
            }
        }
        
        # We are forced to keep 1 die, so we keep the highest value
        if (bad) {
            final = append(final, max(throw))
            dice_left = dice_left - 1
        }
    }
    
    final_sum = sum(final)
    return(final_sum)
}
```

# Order statistics

In the previous strategy, we only decided to keep sixes and fives. Could we improve our strategy by computing the expected value of the next turn based on number of dice kept? Let's try to estimate the maximal value thrown by n dice, since we only need to keep.

If we denote the $k$th order statistic ($k$th lowest element in the sample) as $X_{(k)}$, the probability that the element will equal some value $x$ is computed as

$$
{\displaystyle {\begin{aligned}P(X_{(k)}=x)&=\sum _{j=0}^{n-k}{n \choose j}\left((1-F(x))^{j}(F(x))^{n-j}-(1-F(x)+f(x))^{j}(F(x)-f(x))^{n-j}\right).\end{aligned}}}
$$

However, since we are looking for a maximum ($k=n$), we can simplify this formula. Let's denote three following values:\$\$\mathbf{p_{1}}=P(X\<x)=F(x)-f(x), \mathbf{p_{2}}=P(X=x)=f(x),{\text{ and }}\mathbf{p_{3}}=P(X\>x)=1-F(x).\

Using these, we can transform the formula and simplify:

$$
{\displaystyle {\begin{aligned}P(X_{(k)}=x)&=\sum _{j=0}^{n-k}{n \choose j}\left((1-F(x))^{j}(F(x))^{n-j}-(1-F(x)+f(x))^{j}(F(x)-f(x))^{n-j}\right),\\&=\sum _{j=0}^{n-k}{n \choose j}\left(p_{3}^{j}(p_{1}+p_{2})^{n-j}-(p_{2}+p_{3})^{j}(p_{1})^{n-j}\right),\\&=\sum_{j=0}^{n-n}{n\choose 0} \left( p_3^0(p_1+p_2)^n- (p_2 + p_3)^0(p_1)^n\right),
\\&=(p_1+p_2)^n-p_1^n,
\\&=F(x)^n-\left(F(x)-f(x)\right)^n
\\\end{aligned}}}
$$

\

```{r}
e_max <- function(n){
    e = 0
    for (x in 1:6) {
        Fx=x/6
        fx=1/6
        e = e + x*(Fx**n - (Fx-fx)**n)
    }
    return(e)
}
```

```{r}

```

```{r}
turn_optimal <- function() {
    
    # We will compute expected maximal values for rolls with 1 to 6 dice
    e_maxima <- c()
    for (i in 1:6) {
        e_maxima <- c(e_maxima, e_max(i))
    }
    
    dice_in_game <- 6
    final_hand <- c()
  
    # While we are still left with dice to throw, we will play
    while (dice_in_game > 0) {
    
        throw <- sample.int(n = 6, size = dice_in_game, replace = TRUE)
        initial_throw_size <- length(throw)
        improvement_found <- TRUE
        
        # Now let's choose the dice to keep going from highest value down
        while (improvement_found) {
          
            # Start with no expected improvement
            improvement_found <- FALSE 
          
            if (length(throw) == 0) {
                break
            }
          
            # With more dice left in game, the threshold for keeping is higher
            current_threshold <- e_maxima[length(throw)]
            indices_to_keep <- which(throw >= current_threshold)
          
            # If we want actually want to keep any, we have found an improvement
            if (length(indices_to_keep) > 0) {
                improvement_found <- TRUE 
                final_hand <- append(final_hand, throw[indices_to_keep])
                throw <- throw[-indices_to_keep]
            }
        }
        
        # If we haven't found any sufficient values, we will bite the bullet and
        # keep the highest value
        if (length(throw) == initial_throw_size) {
            max_index <- which.max(throw)
            final_hand <- append(final_hand, throw[max_index])
            throw <- throw[-max_index]
        }
        
        dice_in_game <- length(throw)
    }
  
    return(final_hand)
}
```

```{r}
results <- c()
for (i in 1:10000) {
    results <- append(results, sum(turn_optimal()))
}


hist(results)
quantile(results)
mean(results)
```
