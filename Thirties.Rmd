---
title: "Thirties"
author: "Ota Brzák"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen=10) # Print 0.00513 instead of 5.13e-03.

```

# The rules of the game

For this game analysis, I will be using slightly modiffied rules of the dice game 30s. The rules go like this: player starts with 30 lives and the players take turns clockwise. At the start of a turn, a player gets 6 dice. The goal of a player's turn is to throw the highest sum of all dice, which can be 36 at best.

The turn goes like this: the player throws all dice and has to set aside at least 1 of them. After he sets some dice aside (1 or more), he throws the rest of them again and repeats the process (sets at least 1 ř aside, throws the rest again), until there are no dice to throw and all are set aside. Since each throw contains at least 1 less die than the previous, the player can throw as many as 6 times in a turn.

After the final throw, the dice are summed up. If the result is lower than 30 (this is a recurring number in this game, as the name suggests), difference from 30 is subtracted from the player's lives (if I throw a 27, I lose 3 lives). If the result is higher than 30, the surplus over 30 is subtracted from the lives of the player on the left (if I throw a 35, the player on my left loses 5 lives). The last player with any lives left wins.

The scoring is not too important in this analysis, let's just estabilish that we want to find a strategy, that gets us as much above 30 as possible (ideally as close to 36 as possible). Let's now try to find it!

# Simplest strategy

Ok, a simple strategy would be to keep all the higher numbers and rethrow all the lower numbers. To keep it simple, let's set aside all 5's and 6's and look at what we get.

```{r}
# This function simulates a player's turn
turn <- function() {
    
    # Number of dice still in game
    dice_left = 6
    
    # The number of current throw
    throw_num = 0
    
    # Final result of the turn
    final = c()
    
    while (dice_left>0){
        
        # Enumerate the throw
        throw_num = throw_num + 1
        
        # In a "bad" throw we do not want to keep any dice
        bad = TRUE
        throw = sample.int(6,size = dice_left, replace = TRUE)
        
        # Choose which dice to keep
        for (die in throw){
            
            if (die>=5){
                final = append(final, die)
                dice_left = dice_left - 1
                bad = FALSE
            }
        }
        
        # We are forced to keep 1 die, so we keep the highest value
        if (bad) {
            final = append(final, max(throw))
            dice_left = dice_left - 1
        }
    }
    
    final_sum = sum(final)
    return(final_sum)
}
```

```{r}
turn()
```

Now let's think about this for a minute. Imagine I throw a 5 in a last throw (only 1 die remaining). The expected value for the throw of 1 die is 3,5 and we scored much higher! Great.

But now, what if I throw a 5 in my first throw (with all 6 dice). Is it a good result, or is it not? As we can see, it now gets a bit more complicated. After this first throw, I will have the opportunity to see 15 more dice thrown (5 + 4 + 3 + 2 +1) and there is a pretty good chance we will see a 6 come up (to be exact it is $1-\left(\frac{5}{6}\right)^{15}=0.935$).

This changes our strategy a lot. Theoretically, for each throw ranging from 1 die to 6 dice there is a threshold that tells us whether to keep that die or not. That threshold is different for every throw, starts high and gradually lowers. But just where might this threshhold lie?

# Order statistics

This threshold is called the expected value. Expected value is the weighted average of all possible outcomes and shows us the average result of a throw or even a whole turn. We should start keeping numbers above expected value and try again with numbers below the expected value,

In the previous strategy, we only decided to keep 6s and 5s. Could we improve our strategy by computing the expected value of the next throw based on number we throw with? Let's try to estimate the maximum value thrown by $n$ dice, since we only need to keep 1 die (logically, we want to keep the highest value from a throw).

If we denote the $k$th order statistic ($k$th lowest element in the sample) as $X_{(k)}$, the probability that the element will equal some value $x$ is computed as

$$
{\displaystyle {\begin{aligned}P(X_{(k)}=x)&=\sum _{j=0}^{n-k}{n \choose j}\left((1-F(x))^{j}(F(x))^{n-j}-(1-F(x)+f(x))^{j}(F(x)-f(x))^{n-j}\right).\end{aligned}}}
$$

However, since we are looking for a maximum ($k=n$), we can simplify this formula. Let's denote three following values: $$\mathbf{p_{1}}=P(X<x)=F(x)-f(x), \mathbf{p_{2}}=P(X=x)=f(x),{\text{ and }}\mathbf{p_{3}}=P(X\>x)=1-F(x).$$

Using these, we can transform the formula and simplify:

$$
{\displaystyle {\begin{aligned}P(X_{(k)}=x)&=\sum _{j=0}^{n-k}{n \choose j}\left((1-F(x))^{j}(F(x))^{n-j}-(1-F(x)+f(x))^{j}(F(x)-f(x))^{n-j}\right),\\&=\sum _{j=0}^{n-k}{n \choose j}\left(p_{3}^{j}(p_{1}+p_{2})^{n-j}-(p_{2}+p_{3})^{j}(p_{1})^{n-j}\right),\\&=\sum_{j=0}^{n-n}{n\choose 0} \left( p_3^0(p_1+p_2)^n- (p_2 + p_3)^0(p_1)^n\right),
\\&=(p_1+p_2)^n-p_1^n,
\\&=F(x)^n-\left(F(x)-f(x)\right)^n
\\\end{aligned}}}
$$

\

```{r}
e_max <- function(n){
    e = 0
    for (x in 1:6) {
        Fx=x/6
        fx=1/6
        e = e + x*(Fx**n - (Fx-fx)**n)
    }
    return(e)
}
```

The `e_max()` function will give us the expected maximum value from throwing $n$dice. In 30s, the expected value of the $n$th order statistic (the maximum) look like this:

```{r}
n_range <- 6:1
expected_maxima <- round(e_max(n_range), digits = 2)
data.frame(n = n_range, expected_maximum = expected_maxima)
```

However, the expected maximum value only accounts for 1 die.

```{r}
return_probs <- function(n){
    probs <- c()
    for (x in 1:6) {
        Fx=x/6
        fx=1/6
        probs <- c(probs,(Fx**n - (Fx-fx)**n))
    }
    return(probs)
}
print(return_probs(2))
```

```{r}

e_maxima <- c()
last_max <- 3.5
probs <- return_probs(2)
e <- 0
for (throw in 1:6) {
        
    sides <- 1:6
    sides_alt <- sides
    sides_alt[sides_alt<last_max] <- last_max
    
    top <- throw
    
    e <- e + (throw + sum(sides_alt[1:top])/(top))*probs[throw]
}

```

```{r}
turn <- function(thresholds=c(5,5,5,5,5,5)) {
    
    # We will compute expected maximal values for rolls with 1 to 6 dice
    thresholds <- thresholds

    
    dice_in_game <- 6
    final_hand <- c()
  
    # While we are still left with dice to throw, we will play
    while (dice_in_game > 0) {
    
        throw <- sample.int(n = 6, size = dice_in_game, replace = TRUE)
        initial_throw_size <- length(throw)
        improvement_found <- TRUE
        
        # Now let's choose the dice to keep going from highest value down
        while (improvement_found) {
          
            # Start with no expected improvement
            improvement_found <- FALSE 
          
            if (length(throw) == 0) {
                break
            }
          
            # With more dice left in game, the threshold for keeping is higher
            current_threshold <- thresholds[7-length(throw)]
            indices_to_keep <- which(throw >= current_threshold)
          
            # If we want actually want to keep any, we have found an improvement
            if (length(indices_to_keep) > 0) {
                improvement_found <- TRUE 
                final_hand <- append(final_hand, throw[indices_to_keep])
                throw <- throw[-indices_to_keep]
            }
        }
        
        # If we haven't found any sufficient values, we will bite the bullet and
        # keep the highest value
        if (length(throw) == initial_throw_size) {
            max_index <- which.max(throw)
            final_hand <- append(final_hand, throw[max_index])
            throw <- throw[-max_index]
        }
        
        dice_in_game <- length(throw)
    }
  
    return(sum(final_hand))
}
```

# Brute force solution

```{r}
all_vectors <- expand.grid(rep(list(6:4), 6))

valid_vectors <- all_vectors[apply(all_vectors, 1, function(x) all(diff(x) <= 0)), ]


valid_vectors <- cbind(valid_vectors, rep(0,nrow(valid_vectors)))
names(valid_vectors) <- c(paste0("V", 1:6),"score")
row.names(valid_vectors) <- NULL
print(valid_vectors)
```

```{r}
n_vectors = nrow(valid_vectors)

for (i in 1:n_vectors) {
    
    current_vector <- as.double(valid_vectors[i, ])
    
    sim_results <- replicate(10000, {
        sum(turn(current_vector))
    })
    
    valid_vectors[i,"score"]=mean(sim_results)
    
    cat("iteration", i,"out of",n_vectors, "\n")
}

print(valid_vectors)

```

```{r}
sorted_vectors <- valid_vectors[order(valid_vectors$score, decreasing = TRUE), ]

best_vectors <- head(sorted_vectors, 2)

n_vectors = nrow(best_vectors)

for (i in 1:n_vectors) {
    
    current_vector <- as.double(best_vectors[i, ])
    
    sim_results <- replicate(200000, {
        sum(turn(current_vector))
    })
    
    best_vectors[i,"score"]=mean(sim_results)
    
    cat("iteration", i,"out of",n_vectors, "\n")
}

print(best_vectors)
```

# Genetic algorithm

We have already found a very decent solution through brute force, since in this case there are not that many options for the ideal solution. However, with higher number of options the time to find the optimal solution would grow exponentially (the brute force algorithm has complexity of $\mathcal{O}(2^n)$, which is absolutely horrible). Could there be another way of finding a solution?

Since this game has a very large ammount of outcomes, it would be super tedious to solve analytically. We also do not have any continuous function to optimize, but we could try some sort of a genetic algorithm. For this small example it is a bit overkill, but it is a great learning experience and could help us validate our brute solution.

```{r}
make_population <- function(n) {
    
    population <- replicate(n,sample(1:6, 6, replace = TRUE))
    
    
    population <- as.data.frame(t(population))
    
    col_names <- (c("T1","T2","T3","T4","T5","T6"))
    colnames(population) <- col_names
    population$score <- replicate(n,0)
    
    
    
        
    return(population)
}


```

```{r}
evaluate_population <- function(population,epoch, n_epochs, sampled_turns){
    
    n_chrom <- nrow(population)
    
    cat(paste("\n--- Evaluating Epoch:", epoch, "---\n"))
    
    pb <- txtProgressBar(min = 0, max=n_chrom, style = 3)
    
    for (chrom_i in 1:n_chrom) {
    
        chromosome <- as.double(population[chrom_i,1:6])
        
        
        repetitions <- ceiling(100 + (sampled_turns-100)*(epoch/n_epochs)^3)
        sim_results <- replicate(repetitions,sum(turn(chromosome)))
        
        sim_score <- mean(sim_results)
        population$score[chrom_i] <- sim_score
        
        setTxtProgressBar(pb, chrom_i)        
    }
    close(pb)
    cat("\n")
    return(population)
}


```

```{r}
crossover <- function(chromosome_x, chromosome_y, crossover_point ,prob_mutate){
    
    child <- c(chromosome_x[1:crossover_point], 
               chromosome_y[(crossover_point + 1):6])
    
    if(runif(1)<=prob_mutate){
        
        mutation_index <- sample(1:6,1)
        mutated_value <- child[mutation_index]
        
        if (mutated_value==1) {
            child[mutation_index] <- 2
        }
        
        else if (mutated_value==6) {
            child[mutation_index] <- 5
        }
        else {
            
            if (runif(1)>0.5){
                child[mutation_index] <- mutated_value -1
            }
            else{
                                   child[mutation_index] <- mutated_value + 1 
            }
        }
    }
    return(child)
}

chx = c(1,1,1,1,1,1)
chy = c(6,6,6,6,6,6)
print(crossover(chx,chy,crossover_point = 3,prob_mutate = 0.1))
```

```{r}
reproduce_population <- function(population){
    
    new_population <- list()
    n <- nrow(population)
    for (i in 1:n) {
        
        contestants_index <- sample(1:n, 4,replace = TRUE)
        contestants <- population[contestants_index,]
        
        if (contestants$score[1]>contestants$score[2]) {
            chromosome_x <- as.numeric(contestants[1,1:6])
        }
        else {
            chromosome_x <- as.numeric(contestants[2,1:6])
        }
        
        if (contestants$score[3]>contestants$score[4]) {
            chromosome_y <- as.numeric(contestants[3,1:6])
        }
        else {
            chromosome_y <- as.numeric(contestants[4,1:6]) 
        }
        child <- crossover(chromosome_x = chromosome_x,
                           chromosome_y = chromosome_y,
                           crossover_point = 3,
                           prob_mutate = 0.1)
        child <- c(child,0)
        new_population[[i]] <- child
    }
    new_population <- as.data.frame(do.call(rbind,new_population))
    colnames(new_population) <- colnames(population)
    return(new_population)
}
```

```{r}

evolve <- function(n, n_epochs, sampled_turns, early_stop=5){
    
    best_chromosome <- c(0,0,0,0,0,0,0)
    last_best_chromosome <- c(0,0,0,0,0,0,0)
    i_early_stop <- 0

    for (epoch in 1:n_epochs){
        
        if (epoch==1){
            population <- make_population(n)
        }
        else {
            population <- reproduce_population(population = population)
        }
        
        population <- evaluate_population(population = population,
                                          epoch = epoch,
                                          n_epochs = n_epochs,
                                          sampled_turns = sampled_turns)
        
        last_best_chromosome <- best_chromosome
        best_chromosome <- as.numeric(population[which.max(population$score),])
        cat("--- Best Chromosome:",
            best_chromosome,
            " ---","\n","\n","\n")
        if(identical(last_best_chromosome[1:6],best_chromosome[1:6])){
            i_early_stop <- i_early_stop +1
        }
        else {
            i_early_stop <- 0
        }
        if (i_early_stop>=early_stop) {
            cat("Stopping early, solution did not change for",i_early_stop,"epochs.","\n")
            break
        }
    }
    return(population)
}

evolved_population <- evolve(n = 100,
                             n_epochs = 20,
                             sampled_turns = 5000,
                             early_stop = 5)
```
